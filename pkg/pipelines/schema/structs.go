// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Files produced by a step to share with a following step
type ArtifactList []string

type BitbucketPipelinesSchemaJson struct {
	// Clone corresponds to the JSON schema field "clone".
	Clone *CloneProperties `json:"clone,omitempty"`

	// Defines resources used elsewhere in the pipeline configuration
	Definitions *BitbucketPipelinesSchemaJsonDefinitions `json:"definitions,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image BitbucketPipelinesSchemaJsonImage `json:"image,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *BitbucketPipelinesSchemaJsonOptions `json:"options,omitempty"`

	// Pipelines corresponds to the JSON schema field "pipelines".
	Pipelines BitbucketPipelinesSchemaJsonPipelines `json:"pipelines"`
}

// Defines resources used elsewhere in the pipeline configuration
type BitbucketPipelinesSchemaJsonDefinitions struct {
	// Defines custom caches to be used by pipelines
	Caches BitbucketPipelinesSchemaJsonDefinitionsCaches `json:"caches,omitempty"`

	// Defines services that run in separate Docker containers
	Services BitbucketPipelinesSchemaJsonDefinitionsServices `json:"services,omitempty"`
}

// Defines custom caches to be used by pipelines
type BitbucketPipelinesSchemaJsonDefinitionsCaches map[string]interface{}

// Defines services that run in separate Docker containers
type BitbucketPipelinesSchemaJsonDefinitionsServices map[string]interface{}

type BitbucketPipelinesSchemaJsonImage interface{}

type BitbucketPipelinesSchemaJsonOptions struct {
	// A flag to add Docker to all build steps in all pipelines
	Docker *bool `json:"docker,omitempty"`

	// MaxTime corresponds to the JSON schema field "max-time".
	MaxTime *MaxTime `json:"max-time,omitempty"`

	// Size corresponds to the JSON schema field "size".
	Size *Size_2 `json:"size,omitempty"`
}

type BitbucketPipelinesSchemaJsonPipelines struct {
	// Branch-specific build pipelines
	Branches NamedPipelines `json:"branches,omitempty"`

	// Pipelines that can only be triggered manually or scheduled from the Bitbucket
	// Cloud interface
	Custom BitbucketPipelinesSchemaJsonPipelinesCustom `json:"custom,omitempty"`

	// Default corresponds to the JSON schema field "default".
	Default StepsOrParallel `json:"default,omitempty"`

	// Pull-request-specific build pipelines
	PullRequests NamedPipelines `json:"pull-requests,omitempty"`

	// Tag-specific build pipelines
	Tags NamedPipelines `json:"tags,omitempty"`
}

// Pipelines that can only be triggered manually or scheduled from the Bitbucket
// Cloud interface
type BitbucketPipelinesSchemaJsonPipelinesCustom map[string]interface{}

// Contains settings to clone the repository into a container
type CloneProperties struct {
	// Depth of Git clone (supported only for Git repositories)
	Depth interface{} `json:"depth,omitempty"`

	// Enables cloning of the repository before a step in a pipeline
	Enabled bool `json:"enabled,omitempty"`

	// Enables the download of LFS files in the clone (supported only for Git
	// repositories)
	Lfs bool `json:"lfs,omitempty"`
}

type ComplexArtifacts struct {
	// Enables downloading of all available artifacts at the start of a step
	Download bool `json:"download,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths ArtifactList `json:"paths,omitempty"`
}

type ComplexImage struct {
	// Name corresponds to the JSON schema field "name".
	Name ImageName `json:"name"`

	// Overrides image's default user, specified user UID must be an existing user in
	// the image with a valid home directory
	RunAsUser *float64 `json:"run-as-user,omitempty"`
}

type ComplexImageWithAwsCredentials interface{}

type ComplexImageWithUsernamePassword interface{}

type Image interface{}

// Name of the Docker image which may or may not include registry URL, tag, and
// digest value
type ImageName string

// Maximum amount of minutes a step can execute
type MaxTime float64

type NamedPipelines map[string]interface{}

// Pipe to execute
type Pipe struct {
	// Pipe identifier
	Pipe string `json:"pipe"`

	// Environment variables passed to the pipe
	Variables PipeVariables `json:"variables,omitempty"`
}

// Environment variables passed to the pipe
type PipeVariables map[string]interface{}

type Script []interface{}

type Size string

const SizeA1X Size = "1x"
const SizeA2X Size = "2x"

type Size_1 string

const Size_1_A1X Size_1 = "1x"
const Size_1_A2X Size_1 = "2x"

type Size_2 string

const Size_2_A1X Size_2 = "1x"
const Size_2_A2X Size_2 = "2x"

type Step struct {
	// Build execution unit
	Step *StepStep `json:"step,omitempty"`
}

// Condition to execute a step
type StepCondition struct {
	// Condition on the changesets involved in a pipeline
	Changesets StepConditionChangesets `json:"changesets"`
}

// Condition on the changesets involved in a pipeline
type StepConditionChangesets struct {
	// Condition which executes a step only if any of the modified files matches any
	// of the defined patterns
	IncludePaths []string `json:"includePaths"`
}

// Build execution unit
type StepStep struct {
	// Commands to execute after the step succeeds or fails
	AfterScript Script `json:"after-script,omitempty"`

	// Artifacts corresponds to the JSON schema field "artifacts".
	Artifacts interface{} `json:"artifacts,omitempty"`

	// Caches enabled for the step
	Caches []string `json:"caches,omitempty"`

	// Clone corresponds to the JSON schema field "clone".
	Clone *CloneProperties `json:"clone,omitempty"`

	// Condition corresponds to the JSON schema field "condition".
	Condition *StepCondition `json:"condition,omitempty"`

	// Type of environment for the deployment step, used in the Deployments dashboard
	Deployment *string `json:"deployment,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image StepStepImage `json:"image,omitempty"`

	// Name of the step
	Name *string `json:"name,omitempty"`

	// Commands to execute in the step
	Script Script `json:"script"`

	// Services enabled for the step
	Services []string `json:"services,omitempty"`

	// Size corresponds to the JSON schema field "size".
	Size *Size_1 `json:"size,omitempty"`

	// Specifies if a step runs automatically or only after someone manually triggers
	// it
	Trigger StepStepTrigger `json:"trigger,omitempty"`
}

type StepStepImage interface{}

type StepStepTrigger string

const StepStepTriggerAutomatic StepStepTrigger = "automatic"

// UnmarshalJSON implements json.Unmarshaler.
func (j *StepStepTrigger) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StepStepTrigger {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StepStepTrigger, v)
	}
	*j = StepStepTrigger(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StepStep) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["script"]; !ok || v == nil {
		return fmt.Errorf("field script: required")
	}
	type Plain StepStep
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["trigger"]; !ok || v == nil {
		plain.Trigger = "automatic"
	}
	*j = StepStep(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Size_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Size_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Size_1, v)
	}
	*j = Size_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StepCondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["changesets"]; !ok || v == nil {
		return fmt.Errorf("field changesets: required")
	}
	type Plain StepCondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StepCondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StepConditionChangesets) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["includePaths"]; !ok || v == nil {
		return fmt.Errorf("field includePaths: required")
	}
	type Plain StepConditionChangesets
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StepConditionChangesets(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Size) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Size {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Size, v)
	}
	*j = Size(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Pipe) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pipe"]; !ok || v == nil {
		return fmt.Errorf("field pipe: required")
	}
	type Plain Pipe
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Pipe(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComplexImage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ComplexImage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComplexImage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComplexArtifacts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ComplexArtifacts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["download"]; !ok || v == nil {
		plain.Download = true
	}
	*j = ComplexArtifacts(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CloneProperties) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain CloneProperties
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["depth"]; !ok || v == nil {
		plain.Depth = 50
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = true
	}
	if v, ok := raw["lfs"]; !ok || v == nil {
		plain.Lfs = false
	}
	*j = CloneProperties(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Size_2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Size_2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Size_2, v)
	}
	*j = Size_2(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BitbucketPipelinesSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pipelines"]; !ok || v == nil {
		return fmt.Errorf("field pipelines: required")
	}
	type Plain BitbucketPipelinesSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BitbucketPipelinesSchemaJson(plain)
	return nil
}

const StepStepTriggerManual StepStepTrigger = "manual"

type StepsOrParallel []interface{}

type StepsOrParallelItem interface{}

var enumValues_Size = []interface{}{
	"1x",
	"2x",
}
var enumValues_Size_1 = []interface{}{
	"1x",
	"2x",
}
var enumValues_Size_2 = []interface{}{
	"1x",
	"2x",
}
var enumValues_StepStepTrigger = []interface{}{
	"automatic",
	"manual",
}
